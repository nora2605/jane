file use FFMpeg
file use Jane.IO
file namespace RecodeCopy
file class RecodeCopier

let ConcurrentProcessingLimit: i32,
    Exclusions: str[],
    Inclusions: str[],
    Target: str,
    Recode: str[],
    FFMpegOptions: str[],
    Overwrite: bool,
    LogLevel: str,
    IgnoreErrors: bool

let sem: Semaphore

fn -pC (me.ConcurrentProcessingLimit, 
    me.Exclusions,
    me.Inclusions,
    me.Target,
    me.Recode,
    me.FFMpegOptions,
    me.Overwrite,
    me.LogLevel,
    me.Ignore) {
    sem = new(ConcurrentProcessingLimit)
}

fn Abbreviate(p: str, maxchars = 20) -> str {
    if (p.Length <= maxchars) ret p

    let dir: str[] = Path.DirectoryName(p)?.Split(DIRECTORY_SEPERATOR) ?? []
    let result: str

    for let part in dir {
        if (result.Length + part.Length + 3 < maxchars)
            result = Path.Combine(result, part)
        else {
            result = Path.Combine(result, "...")
            break
        }
    }
    Path.Combine(result, Path.FileName(p))
}

fn -a ProcessFile(src: str, dest: str, file: str) {
    let filePath: str = Path.Combine(src, file)
    let ext: str = Path.GetExtension(file)
    if (Inclusions ~ Recode ~ Target).Contains(ext) {
        if !Directory.Exists(dest) {
            if (LogLevel == "default" || LogLevel == "verbose")
                Tty.WriteLn("Created directory: ${dest}".Italic().Bold())
            Directory.MKDir(dest)
            if !Directory.Exists(dest) {
                Tty.WriteErrorLn("Unable to create directory. Device might have been removed or invalid permissions.")
                Exit(2)
            }
        }
        let fileDest: str = Path.Combine(dest, Recode.Contains(ext) ? file.Replace(ext, ".mp3") : file)
        if (!Overwrite && File.Exists(fileDest))
            if (LogLevel == "default" || LogLevel == "verbose")
                Tty.WriteLn("Skipped ${Path.GetFileName(filePath)}".Italic().Yellow())
        else await RecodeFile(ext, filePath, fileDest)
    }
}
fn -a RecodeFile(string ext, string filePath, string fileDest) {
    sem.WaitOne()

    if Recode.Contains(ext) {
        let e = new FFMpegEngine()
        let md = await e.GetMetaDataAsync(filePath)
        let t = e.ExecuteAsync("-y -stats -i \"${filePath}\" ${FFMpegOptions.Join(" ")} \"${fileDest}\"")
        if LogLevel == "verbose" {
            e.Progress.AddHandler((sender, ev) =>
                Tty.WriteLn(
                    "Converting ${Abbreviate(Path.GetFileName(filePath))}... ${(100 * ev.ProcessedDuration / md.Result.Duration).f("0.0")}% done".Green().Italic()
                )
            )
        }
        e.Error.AddHandler((sender, err) =>
        {
            if (LogLevel != "quiet") Tty.WriteLn("Error converting ${Path.GetFileName(filePath)}: ${err}").Bold().Red()
            if (!IgnoreErrors) Exit(1)
        })
        t.Wait()
        if (LogLevel == "default" || LogLevel == "verbose")
            Tty.WriteLn("Successfully converted ${Path.GetFileName(filePath)}".Bold().Green())
    } else {
        File.Copy(filePath, fileDest, Overwrite)
        if (LogLevel == "default" || LogLevel == "verbose")
            Tty.WriteLn("Copied ${Path.GetFileName(filePath)} to ${fileDest}".Bold().Blue())
    }

    sem.Release()
}
fn -ap Process(input: str, output: str, rootSource?: str) -> abyss
{
    if (!rootSource?) rootSource = input
    let files: str[] = Directory.GetEntries(input)
        .Map(x => Path.GetFileName(x))
    let tasks: Task[] = []
    for let file in files {
        let filePath = Path.Combine(input, file)
        if !Exclusions.Any(filePath.Contains) {
            try {
                FileAttributes attr = File.GetAttributes(filePath)
                if (attr &== FileAttributes.Directory)
                    tasks.Add(Process(filePath, Path.Combine(output, file), rootSource))
                else tasks.Add(ProcessFile(input, output, file))
            } catch (Error err) {
                if (LogLevel != "quiet") Tty.WriteErrorLn("\nError processing ${filePath}: ${err}".Red())
                if (!IgnoreErrors) Exit(1)
            }
        } else if (LogLevel == "verbose") Tty.WriteLn("Skipped file ${file} due to exclusions".Yellow().Italic())
    }
    tasks.Map(x => x.Wait())
}