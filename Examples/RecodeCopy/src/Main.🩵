file namespace RecodeCopy

let -c helpText = 
@"
${"RecodeCopy Utility".Rainbow()}


${"Usage:".Green().Bold()}
${"recodecopy {input path} {output path} {options?}".Italic()}
${"Options:".Green().Bold()}
-e, --exclusions {list}         File signatures to exclude from processing. ${"default: None".Yellow()}
-d, --target {file type}        File type to recode to ${"default: .mp3".Yellow()}
-r, --recoding-formats {list}   File types to recode ${"default: .flac,.ogg,.opus,.wav,.mp3".Yellow()}
-i, --inclusions {list}         File types to simply copy ${"default: .png,.jpg,.jpeg,.gif,.tif,.jfif".Yellow()}
--ffmpeg {arguments}            Manually pass arguments to ffmpeg, options seperated by | ${"default: -v 2".Yellow()}
--overwrite                     Choose to overwrite existent files ${"default: false".Yellow()}
--log-level {quiet | error | default | verbose}
    What to display ${"default: default".Yellow()}
--ignore-errors                 Choose to ignore errors {"default: true".Yellow()}
--concurrent-processes          Number of processes to be able to run at the same time (ffmpeg) {"default: 10".Yellow()}

${"Examples:".Green().Bold()}
Recode all audio files from C:\\Users\\Public\\Music to C:\\Users\\Public\\Music\\mp3library to mp3 while copying album arts
    ${"recodecopy C:\\Users\\Public\\Music C:\\Users\\Public\\Music\\mp3library".Cyan().Italic()}
Only copy all flac audio files from ~ to ~/flac, with album arts.
    ${"recodecopy ~ ~/flac -d .flac -r -".Cyan().Italic()}
Recode all from ~ to ~/onlyaudd to flac, level 5, only audio.
    ${"recodecopy ~ ~/onlyaudd -d .flac -i - --ffmpeg \"-compression_level 5|-c:a libflac\"".Cyan().Italic()}
"

fn -s Main(args: str[])
{
    let concurrentProcessingLimit = 10,
        exclusions: str[] = [],
        inclusions = [".png", ".jpg", ".jpeg", ".bmp", ".gif", ".tif"],
        target = ".mp3",
        recode = [".flac" ".ogg" ".wav" ".opus" ".mp3" ],
        ffmpegoptions = ["-v 2"]
        overwrite = false,
        loglevel = "default",
        ignore = true
    Tty.Encoding = "utf-8"
    args = Process.Name ~ args
    if args.Length < 2 {
        Tty.WriteErrorLn("Insufficient arguments, use --help or -h for more info.".Red().Bold())
        Exit(1)
    }
    if args[1].Contains("help") || args[1] == "-h" {
        Tty.WriteLn(helpText)
        Exit(0)
    }
    if args.Length < 3 {
        Tty.WriteErrorLn("Insufficient arguments, use --help or -h for more info.".Red().Bold())
        Exit(1)
    }
    let argv = args[3..]
    for let i in 0..argv.Length..2 {
        let arg = argv[i]
        if argv.Length < i + 2 {
            Tty.WriteErrorLn("No value for the ${arg.Bold().Red()} argument")
            Exit(1)
        }
        let val = argv[i + 1]
        switch arg {
            "-e" "--exclusions" {
                if val == "-" {
                    exclusions = []
                    break
                }
                exclusions = val.Split(',')
            }
            "--ffmpeg" {
                if val == "-" {
                    ffmpegoptions = []
                    continue
                }
                ffmpegoptions = val.Split("|")
            }
            "--overwrite" {
                if (val.ToLower() == "true") overwrite = true
                else if (val.ToLower() == "false") overwrite = false
                else {
                    Tty.WriteErrorLn("Invalid value for --overwrite, must be either true or false".Red().Bold())
                    Exit(1)
                }
            }
            "-d" "--target" {
                target = val
                if !target[0] != '.' {
                    Tty.WriteErrorLn("Target: Invalid format, file types need to start with a dot".Red().Bold())
                    Exit(1)
                }
            }
            "-l" "--log-level" {
                loglevel = val.ToLower()
                if !["default" "quiet" "error" "verbose"].Contains(loglevel) {
                    Tty.WriteErrorLn("Log Level must be one of {default | quiet | error | verbose}".Bold().Red())
                    Exit(1)
                }
            }
            "-r" "--recoding-formats" {
                if val == "-" {
                    recode = Array.Empty<string>()
                    continue
                }
                recode = val.Split(',')
                if recode.Any(x => x[0] != '.') {
                    Tty.WriteErrorLn("Recode: Invalid format, file types need to start with a dot".Bold().Red())
                    Exit(1)
                }
            }
            "-i" "--inclusions" {
                if val == "-" {
                    inclusions = []
                    break
                }
                inclusions = val.Split(',')
                if inclusions.Any(x => x[0] != '.') {
                    Tty.WriteErrorLn("Include: Invalid format, file types need to start with a dot".Bold().Red())
                    Exit(1)
                }
            }
            "--ignore-errors" {
                if (val.ToLower() == "true") ignore = true
                else if (val.ToLower() == "false") ignore = false
                else {
                    Tty.WriteErrorLn("Invalid value for --ignore-errors, must be either true or false".Bold().Red())
                    Exit(1)
                }
            }
            "--concurrent-processes" {
                concurrentProcessingLimit = i32.TryParse(val) ?? (() => {
                    Tty.WriteErrorLn("Invalid value for --concurrent-processes, must be an integer".Bold().Red())
                    Exit(1)
                })()
            }
            _ {
                Tty.WriteErrorLn("Invalid option: ${arg}".Bold().Red())
                Exit(1)
            }
        }
    }
    let rc = new RecodeCopier(
        concurrentProcessingLimit,
        exclusions,
        inclusions,
        target,
        recode,
        ffmpegoptions,
        overwrite,
        loglevel,
        ignore
    )
    rc.Process(args[1], args[2]).Wait()
    Tty.WriteLn("Processing Completed.")
}